extern crate protobuf_codegen_pure;

use indoc::indoc;
use notify::{watcher, RecursiveMode, Watcher};
use std::ffi::OsStr;
use std::fs;
use std::fs::{DirEntry, File, FileType};
use std::io::{Error, Write};
use std::sync::mpsc::channel;
use std::time::Duration;

fn main() -> std::io::Result<()> {
    //
    // CSS
    //

    let mut generated_css_file = File::create("../ui/src/view/style/gen.css")?;
    generated_css_file.write_all(css().as_bytes())?;

    let mut style_constants_code = File::create("../ui/src/view/style/gen_const.rs")?;
    style_constants_code.write_all(style_constants().as_bytes())?;

    //
    // PROTOBUF
    //

    protobuf_codegen_pure::run(protobuf_codegen_pure::Args {
        out_dir: "src/protos",
        input: &["src/protos/game_request.proto"],
        includes: &["src/protos"],
        customize: protobuf_codegen_pure::Customize {
            serde_derive: Some(true),
            ..Default::default()
        },
    })
    .expect("protoc");

    //
    // CONCAT CSS
    //

    concat_all_css()?;
    // Create a channel to receive the events.
    let (sender, receiver) = channel();

    // Create a watcher object, delivering debounced events.
    // The notification back-end is selected based on the platform.
    let mut watcher = watcher(sender, Duration::from_secs(10)).unwrap();

    // Add a path to be watched. All files and directories at that path and
    // below will be monitored for changes.
    watcher
        .watch("../ui/src/view", RecursiveMode::Recursive)
        .unwrap();

    loop {
        match receiver.recv() {
            Ok(event) => {
                println!("{:?}", event);
                concat_all_css()?;
            }
            Err(e) => println!("watch error: {:?}", e),
        }
    }
}

fn concat_all_css() -> std::io::Result<()> {
    let mut concatenated_css = String::new();
    read_and_concat_path("../ui/src", &mut concatenated_css);

    let mut main_css_file = File::create("../ui/style.css")?;
    main_css_file.write_all(concatenated_css.as_bytes())
}

fn read_and_concat_path(path: &str, buf: &mut String) {
    let dir = fs::read_dir(path).unwrap();

    for dir_item_read_result in dir {
        match dir_item_read_result {
            Ok(dir_item) => {
                let path = dir_item.path();

                match path.to_str() {
                    None => {
                        panic!("Cannot turn the path into a string");
                    }
                    Some(entry_path) => {
                        let extension = path.extension().and_then(OsStr::to_str);
                        if extension == Some("css") {
                            match fs::read_to_string(entry_path) {
                                Ok(file_content) => {
                                    buf.push_str("\n\n");
                                    buf.push_str(file_content.as_str());
                                }
                                Err(file_read_error) => {
                                    panic!(file_read_error);
                                }
                            }
                        }

                        if path.is_dir() {
                            read_and_concat_path(entry_path, buf);
                        }
                    }
                }
            }
            Err(error) => {
                panic!(error);
            }
        }
    }
}

static MAX_STYLE_SIZE: u8 = 8;
static SIDES: [&str; 4] = ["top", "bottom", "left", "right"];

fn indent(buf: &mut String, size: u8, with_text: &str) {
    let tab: String = (0..(4 * size)).map(|_| " ").collect();

    buf.push_str(tab.as_str());
    buf.push_str(with_text);
}

////////////////////////////////////////////////////////////////
// STYLE CODE //
////////////////////////////////////////////////////////////////

fn style_constants() -> String {
    let mut buf: String = String::new();

    buf.push_str(indoc!(
        r#"
        ///
        /// Do not edit this file by hand! This file was generated. Change the script that
        /// generates this code instead and re-run it.
        ///
        /// The script is located in code-gen/src/main.rs
        ///
        
        "#
    ));

    let mut size = 0;

    while size < MAX_STYLE_SIZE {
        let mut side_index = 0;

        while side_index < SIDES.len() {
            let side = SIDES[side_index];

            buf.push_str(spacing_constant("margin", side, size).as_str());
            buf.push('\n');
            buf.push_str(spacing_constant("padding", side, size).as_str());
            buf.push('\n');

            side_index += 1;
        }

        size += 1;
    }

    for side in SIDES.iter() {
        buf.push_str(spacing_function("margin", side).as_str());
        buf.push('\n');
        buf.push_str(spacing_function("padding", side).as_str());
        buf.push('\n');
    }

    buf
}

fn spacing_function(has_side: &str, side: &str) -> String {
    let mut buf: String = String::new();

    buf.push_str(
        format!(
            "pub fn {}(size: u8) -> &'static str {{\n",
            format!("{}_{}", has_side, side),
        )
        .as_str(),
    );

    indent(&mut buf, 1, "match size {\n");

    let mut size: u8 = 0;

    while size < MAX_STYLE_SIZE {
        indent(
            &mut buf,
            2,
            format!(
                "{} => {}_{}_{},\n",
                size,
                has_side.to_ascii_uppercase(),
                side.to_ascii_uppercase(),
                size
            )
            .as_str(),
        );

        size += 1;
    }

    indent(
        &mut buf,
        2,
        format!(
            "_ => {}_{}_0,",
            has_side.to_ascii_uppercase(),
            side.to_ascii_uppercase()
        )
        .as_str(),
    );

    buf.push('\n');
    indent(&mut buf, 1, "}\n");
    buf.push('}');

    buf
}

fn spacing_constant(has_side: &str, side: &str, size: u8) -> String {
    format!(
        "pub static {}: &'static str = {};",
        format!(
            "{}_{}_{}",
            has_side.to_ascii_uppercase(),
            side.to_ascii_uppercase(),
            size
        ),
        format!("\"{}-{}-{}\"", has_side, side, size)
    )
}

////////////////////////////////////////////////////////////////
// CSS //
////////////////////////////////////////////////////////////////

fn css() -> String {
    let mut buf: String = String::new();

    buf.push_str(indoc!(
        r#"
        /*
        Do not edit this file by hand! This file was generated. Change the script that
        generates this css instead and re-run it.
        
        The script is located in code-gen/src/main.rs
        */
        
        "#
    ));

    let mut size = 0;

    while size < MAX_STYLE_SIZE {
        let mut side_index = 0;

        while side_index < SIDES.len() {
            let side = SIDES[side_index];

            buf.push_str(side_style_str("margin", side, size).as_str());
            buf.push_str("\n\n");
            buf.push_str(side_style_str("padding", side, size).as_str());
            buf.push_str("\n\n");

            side_index += 1;
        }

        size += 1;
    }

    buf
}

fn side_style_str(has_side: &str, side: &str, size: u8) -> String {
    let base_number: u32 = 2;
    format!(
        "{}{}",
        format!(".{}-{}-{} {{\n", has_side, side, size),
        format!(
            "    {}-{}: {}px;\n}}",
            has_side,
            side,
            base_number.pow(size as u32)
        )
    )
    .to_owned()
}
